window.FluidSim = function(canvasId, options) {
  options = options || {};

  options.initVFn = options.initVFn || function(x, y) {
    return [0.05 * Math.sin(2 * Math.PI * y), 0.05 * Math.sin(2 * Math.PI * x)];
  };

  if (options.threshold === undefined) {
    options.threshold = true;
  }

  if (options.advectV === undefined) {
    options.advectV = true;
  }

  if (options.applyPressure === undefined) {
    options.applyPressure = false;
  }

  if (options.showArrows === undefined) {
    options.showArrows = true;
  }

  // For silly reasons, these have to be equal for now.
  // This is because I assumed grid spacing was equal along
  // each axis, so if you want to change these to not be equal, you'd have to
  // carefully go through the code and decide which values of EPSILON should be
  // 1/WIDTH, and which should be 1/HEIGHT.
  var WIDTH = 400;
  var HEIGHT = WIDTH;
  var EPSILON = 1/WIDTH;

  // We assume every time step will be a 60th of a second.
  // In practice, this won't be real-time, but we'd rather our simulation run
  // behind than need to run a very large time step, since it would cause
  // instability in the simulation.
  var DELTA_T = 1/60.0;

  // We arbitrarily set our fluid's density to 1 (this is rho in equations)
  var DENSITY = 1.0;

  var canvas = document.getElementById(canvasId);
  canvas.style.margin = "0 auto";
  canvas.style.display = "block";

  var gl = GL.create(canvas);
  gl.canvas.width = WIDTH;
  gl.canvas.height = HEIGHT;
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  // Standard 2-triangle mesh covering the viewport
  // when draw with gl.TRIANGLE_STRIP
  var standardMesh = gl.Mesh.load({
    vertices: [
      [-1, 1],
      [1, 1],
      [-1, -1],
      [1, -1]
    ],
    coords: [
      [0, 1],
      [1, 1],
      [0, 0],
      [1, 0]
    ]
  });

  var standardVertexShaderSrc = `
  varying vec2 textureCoord;
  void main() {
    textureCoord = gl_TexCoord.xy;
    gl_Position = gl_Vertex;
  }`;

  // Given a texture holding a 2D velocity field, draw arrows
  // showing the direction of the fluid flow.
  var drawVectorFieldArrows = (function() {
    var shader = new gl.Shader(`
      mat2 rot(float angle) {
        float c = cos(angle);
        float s = sin(angle);

        return mat2(
          vec2(c, -s),
          vec2(s, c)
        );
      }

      attribute vec2 position;
      uniform sampler2D velocity;
      void main() {
        vec2 v = texture2D(velocity, (position + 1.0) / 2.0).xy;
        float scale = length(v);
        float angle = atan(v.y, v.x);
        mat2 rotation = rot(-angle);
        gl_Position = vec4(
          (rotation * (scale * gl_Vertex.xy)) + position,
          0.0, 1.0);
      }
    `, `
      void main() {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
      }
    `);
    
    // Triangle pointing towards positive x axis
    // with baseline on the y axis
    var triangleVertices = [
      [0, 0.2],
      [1, 0],
      [0, -0.2]
    ];

    var arrowsMesh = new gl.Mesh({triangles: false});
    arrowsMesh.addVertexBuffer('positions', 'position');
    
    var INTERVAL = 30;
    
    for (var i = INTERVAL / 2; i < HEIGHT; i += INTERVAL) {
      for (var j = INTERVAL / 2; j < WIDTH; j += INTERVAL) {
        for (var k = 0; k < 3; k++) {
          arrowsMesh.vertices.push(triangleVertices[k]);
          arrowsMesh.positions.push([2 * j / WIDTH - 1, 2 * i / HEIGHT - 1]);
        }
      }
    }
    arrowsMesh.compile();
    
    return function(velocityTexture) {
      velocityTexture.bind(0);
      shader.uniforms({
        velocity: 0
      });
      
      shader.draw(arrowsMesh, gl.TRIANGLES);    
    };
  })();

  // Given glsl expressions for r, g, b, a mapping (x, y) -> a value, return
  // a function that will paint a color generated by that function evaluated at
  // every pixel of the output buffer. (x, y) will be in texture coordinates
  // ([0, 1], [0, 1]).
  var makeFunctionPainter = function(r, g, b, a) {
    r = r || '0.0';
    g = g || '0.0';
    b = b || '0.0';
    a = a || '0.0';

    var shader = new gl.Shader(standardVertexShaderSrc, `
      varying vec2 textureCoord;
      void main() {
        gl_FragColor = vec4(${r}, ${g}, ${b}, ${a});
      }
    `);

    return function() {
      shader.draw(standardMesh, gl.TRIANGLE_STRIP);
    };
  };

  var drawBlack = makeFunctionPainter('0.0', '0.0', '0.0', '1.0');

  // Draw a texture directly to the framebuffer.
  // Will stretch to fit, but in practice the texture and the framebuffer should be
  // the same size.
  var drawTexture = (function() {
    var shader = new gl.Shader(standardVertexShaderSrc, `
      varying vec2 textureCoord;
      uniform sampler2D inputTexture;
      void main() {
        gl_FragColor = texture2D(inputTexture, textureCoord);
      }
    `);
    
    return function(inputTexture) {
      inputTexture.bind(0);
      shader.uniforms({
        input: 0
      });
      shader.draw(standardMesh, gl.TRIANGLE_STRIP)
    };
  })();

  // Draw a texture to the framebuffer, thresholding at 0.5
  var drawTextureThreshold = (function() {
    var shader = new gl.Shader(standardVertexShaderSrc, `
      varying vec2 textureCoord;
      uniform sampler2D inputTexture;
      void main() {
        gl_FragColor = step(0.5, texture2D(inputTexture, textureCoord));
      }
    `);
    
    return function(inputTexture) {
      inputTexture.bind(0);
      shader.uniforms({
        input: 0
      });
      shader.draw(standardMesh, gl.TRIANGLE_STRIP)
    };  
  })();

  // Given an velocity texture and a time delta, advect the
  // quantities in the input texture into the output texture
  var advect = (function() {
    var shader = new gl.Shader(standardVertexShaderSrc, `
      uniform float deltaT;
      uniform sampler2D inputTexture;
      uniform sampler2D velocity;
      varying vec2 textureCoord;

      void main() {
        vec2 u = texture2D(velocity, textureCoord).xy;

        // The 0.5 multiplier below is because the velocities are specified on
        // the domain ([-1, 1], [-1, 1]), but texture coordinates operate on the
        // range ([0, 0], [1, 1]).
        //
        // TODO(jlfwong): For reasons unclear to me, using a multiplier of 0.5
        // instead of 2.0 causes lookups on the left-hand side to not wrap
        // around when looking at the right-moving grid under the "Advection"
        // header. My guess would be the filtering bias is wrong.
        vec2 pastCoord = fract(textureCoord - (2.0 * deltaT * u));
        gl_FragColor = texture2D(inputTexture, pastCoord);
      }
    `);

    return function(inputTexture, velocityTexture) {
      inputTexture.bind(0);
      velocityTexture.bind(1);

      shader.uniforms({
        deltaT: DELTA_T,
        input: 0,
        velocity: 1
      });
      shader.draw(standardMesh, gl.TRIANGLE_STRIP);
    };
  })();

  // Apply a "splat" of velocity change to a given place with a given
  // blob radius. The effect of the splat has an exponential falloff.
  var addVelocitySplat = (function() {
    var shader = new gl.Shader(standardVertexShaderSrc, `
      uniform vec2 velocityChange;
      uniform vec2 center;
      uniform float radius;
      uniform sampler2D velocity;

      varying vec2 textureCoord;

      void main() {
        float dx = center.x - textureCoord.x;
        float dy = center.y - textureCoord.y;
        vec2 v = texture2D(velocity, textureCoord).xy;
        vec2 newV = v + velocityChange * exp(-(dx * dx + dy * dy) / radius);
        gl_FragColor = vec4(newV, 0.0, 1.0);
      }
    `);

    return function(velocityTexture, velocityChange, center, radius) {
      velocityTexture.bind(0);
      shader.uniforms({
        velocityChange: velocityChange,
        center: center,
        radius: radius,
        velocity: 0
      });
      shader.draw(standardMesh, gl.TRIANGLE_STRIP);
    };
  })();

  // Calculate the divergence of the advected velocity field, and multiply by
  // (2 * epsilon * rho / deltaT).
  var calcDivergence = (function() {
    var shader = new gl.Shader(standardVertexShaderSrc, `
      uniform float deltaT;         // Time between steps
      uniform float rho;            // Density
      uniform float epsilon;        // Distance between grid units
      uniform sampler2D velocity;   // Advected velocity field, u_a

      varying vec2 textureCoord;

      vec2 u(vec2 coord) {
        return texture2D(velocity, fract(coord)).xy;
      }

      void main() {
        gl_FragColor = vec4((-2.0 * epsilon * rho / deltaT) * (
          (u(textureCoord + vec2(epsilon, 0)).x -
           u(textureCoord - vec2(epsilon, 0)).x)
          +
          (u(textureCoord + vec2(0, epsilon)).y -
           u(textureCoord - vec2(0, epsilon)).y)
        ), 0.0, 0.0, 1.0);
      }
    `);

    return function(velocityTexture) {
      velocityTexture.bind(0);
      shader.uniforms({
        velocity: 0,
        epsilon: EPSILON,
        deltaT: DELTA_T,
        rho: DENSITY
      });
      shader.draw(standardMesh, gl.TRIANGLE_STRIP);
    };
  })();

  // Perform a single iteration of the Jacobi method in order to solve for
  // pressure.
  var jacobiIterationForPressure = (function() {
    var shader = new gl.Shader(standardVertexShaderSrc, `
      uniform float epsilon;        // Distance between grid units
      uniform sampler2D divergence; // Divergence field of advected velocity, d
      uniform sampler2D pressure;   // Pressure field from previous iteration, p^(k-1)

      varying vec2 textureCoord;

      float d(vec2 coord) {
        return texture2D(divergence, fract(coord)).x;
      }

      float p(vec2 coord) {
        return texture2D(pressure, fract(coord)).x;
      }

      void main() {
        gl_FragColor = vec4(0.25 * (
          d(textureCoord)
          + p(textureCoord + vec2(2.0 * epsilon, 0.0))
          + p(textureCoord - vec2(2.0 * epsilon, 0.0))
          + p(textureCoord + vec2(0.0, 2.0 * epsilon))
          + p(textureCoord - vec2(0.0, 2.0 * epsilon))
        ), 0.0, 0.0, 1.0);
      }
    `);

    return function(divergenceTexture, pressureTexture) {
      divergenceTexture.bind(0);
      pressureTexture.bind(1);
      shader.uniforms({
        divergence: 0,
        pressure: 1,
        epsilon: EPSILON
      });
      shader.draw(standardMesh, gl.TRIANGLE_STRIP);
    };
  })();

  // Subtract the pressure gradient times a constant from the advected velocity
  // field.
  var subtractPressureGradient = (function() {
    var shader = new gl.Shader(standardVertexShaderSrc, `
      uniform float deltaT;         // Time between steps
      uniform float rho;            // Density
      uniform float epsilon;        // Distance between grid units
      uniform sampler2D velocity;   // Advected velocity field, u_a
      uniform sampler2D pressure;   // Solved pressure field

      varying vec2 textureCoord;

      float p(vec2 coord) {
        return texture2D(pressure, fract(coord)).x;
      }

      void main() {
        vec2 u_a = texture2D(velocity, textureCoord).xy;

        float diff_p_x = (p(textureCoord + vec2(epsilon, 0.0)) -
                          p(textureCoord - vec2(epsilon, 0.0)));
        float u_x = u_a.x - deltaT/(2.0 * rho * epsilon) * diff_p_x;

        float diff_p_y = (p(textureCoord + vec2(0.0, epsilon)) -
                          p(textureCoord - vec2(0.0, epsilon)));
        float u_y = u_a.y - deltaT/(2.0 * rho * epsilon) * diff_p_y;

        gl_FragColor = vec4(u_x, u_y, 0.0, 0.0);
      }
    `);

    return function(velocityTexture, pressureTexture) {
      velocityTexture.bind(0);
      pressureTexture.bind(1);
      shader.uniforms({
        velocity: 0,
        pressure: 1,
        epsilon: EPSILON,
        deltaT: DELTA_T,
        rho: DENSITY
      });
      shader.draw(standardMesh, gl.TRIANGLE_STRIP);
    };
  })();

  var velocityData = new Float32Array(WIDTH * HEIGHT * 4);
  var inkData = new Float32Array(WIDTH * HEIGHT * 4);

  var gridSize = Math.floor(WIDTH / 12);

  for (var i = 0; i < HEIGHT; i++) {
    var y = -((i / HEIGHT) * 2 - 1);
    for (var j = 0; j < WIDTH; j++) {
      var x = (j / WIDTH) * 2 - 1;
      
      var offset = (i * WIDTH + j) * 4;

      var initVal = options.initVFn(x, y);
      velocityData[offset + 0] = initVal[0];
      velocityData[offset + 1] = initVal[1];

      var brightness = (Math.floor(i / gridSize) + Math.floor(j / gridSize)) % 2;
      
      inkData[offset + 0] = brightness;
      inkData[offset + 1] = brightness;
      inkData[offset + 2] = brightness;
      inkData[offset + 3] = 1;
    }
  }

  var velocityTexture0 = new gl.Texture(WIDTH, HEIGHT, {
    type: gl.FLOAT,
    data: velocityData
  });

  var velocityTexture1 = new gl.Texture(WIDTH, HEIGHT, {
    type: gl.FLOAT
  });

  var colorTexture0 = new gl.Texture(WIDTH, HEIGHT, {
    type: gl.FLOAT,
    data: inkData
  });

  var colorTexture1 = new gl.Texture(WIDTH, HEIGHT, {
    type: gl.FLOAT
  });

  var divergenceTexture = new gl.Texture(WIDTH, HEIGHT, {
    type: gl.FLOAT
  });

  var pressureTexture0 = new gl.Texture(WIDTH, HEIGHT, {
    type: gl.FLOAT
  });

  var pressureTexture1 = new gl.Texture(WIDTH, HEIGHT, {
    type: gl.FLOAT
  });

  pressureTexture0.drawTo(function() {
    drawBlack();
  });

  // Reset the simulation on double click
  canvas.addEventListener('dblclick', function() {
    // TODO(jlfwong): Stop allocating these textures, and just draw the initial
    // states in shaders instead.
    velocityTexture0 = new gl.Texture(WIDTH, HEIGHT, {
      type: gl.FLOAT,
      data: velocityData
    });

    colorTexture0 = new gl.Texture(WIDTH, HEIGHT, {
      type: gl.FLOAT,
      data: inkData
    });
  });

  var onScreen = function() {
    var container = canvas.offsetParent;
    return (container.scrollTop < canvas.offsetTop + canvas.height &&
            container.scrollTop + container.offsetHeight > canvas.offsetTop);
  };

  gl.ondraw = function() {
    if (!onScreen()) return;
    gl.clearColor(1.0, 1.0, 1.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    if (options.threshold) {
      drawTextureThreshold(colorTexture0);
    } else {
      drawTexture(colorTexture0);
    }

    if (options.showArrows) {
      drawVectorFieldArrows(velocityTexture0);
    }
  };

  gl.onupdate = function() {
    if (!onScreen()) return;

    if (options.advectV) {
      // Advect the velocity texture through itself, leaving the result in
      // velocityTexture0
      velocityTexture1.drawTo(function() {
        advect(velocityTexture0, velocityTexture0);
      });
      [velocityTexture0, velocityTexture1] = [velocityTexture1, velocityTexture0];
    }

    if (options.applyPressure) {
      // Calculate the divergence, leaving the result in divergenceTexture
      divergenceTexture.drawTo(function() {
        calcDivergence(velocityTexture0);
      });

      // Calculate the pressure, leaving the result in pressureTexture0
      var JACOBI_ITERATIONS = 10;

      // Clear the pressure texture for our first guess:
      // TODO(jlfwong): It might be better to leave this alone -- the previous
      // contents of the texture might be a very good estimate of the current
      // solution.
      /*
      pressureTexture0.drawTo(function() {
        drawBlack();
      });
      */
      for (var i = 0; i < JACOBI_ITERATIONS; i++) {
        pressureTexture1.drawTo(function() {
          jacobiIterationForPressure(divergenceTexture, pressureTexture0);
        });
        [pressureTexture0, pressureTexture1] = [pressureTexture1, pressureTexture0];
      }

      // Subtract the pressure gradient from the advected velocity texture,
      // leaving the result in velocityTexture0
      velocityTexture1.drawTo(function() {
        subtractPressureGradient(velocityTexture0, pressureTexture0);
      });
      [velocityTexture0, velocityTexture1] = [velocityTexture1, velocityTexture0];
    }

    // Advect the color field, leaving the result in colorTexture0
    colorTexture1.drawTo(function() {
      advect(colorTexture0, velocityTexture0);
    });
    [colorTexture0, colorTexture1] = [colorTexture1, colorTexture0];
  };

  gl.onmousemove = function(ev) {
    if (ev.dragging) {
      velocityTexture1.drawTo(function() {
        addVelocitySplat(
          velocityTexture0,
          [ev.deltaX / WIDTH, -ev.deltaY / HEIGHT],
          [ev.offsetX / WIDTH, 1.0 - ev.offsetY / HEIGHT],
          0.01
        );
      });
      [velocityTexture0, velocityTexture1] = [velocityTexture1, velocityTexture0];
    }
  };

  gl.animate();
};
